<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <!-- é€‚é…ç§»åŠ¨è®¾å¤‡çš„è§†å£è®¾ç½®ï¼Œç¡®ä¿å®Œå…¨å“åº”å¼ -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D æ‰‹åŠ¿æ§åˆ¶ç²’å­ç³»ç»Ÿ (æœ€ç»ˆé™æ€ç‰ˆ)</title>
    <!-- å¼•å…¥ Tailwind CSS (ç”¨äºUIå…ƒç´ çš„å¿«é€Ÿç¾åŒ–) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* å¯¼å…¥ Inter å­—ä½“ï¼Œä¿è¯ UI ç¾è§‚ */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #000000;
        }

        /* Three.js å®¹å™¨ */
        #container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* è§†é¢‘æµå’Œç”»å¸ƒçš„å®¹å™¨ï¼Œç”¨äºæ‰‹åŠ¿è¯†åˆ« (éšè—) */
        #video-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            visibility: hidden; 
            z-index: 0;
        }

        /* éšè—çš„è§†é¢‘å’Œç”»å¸ƒå…ƒç´  */
        #webcam, #output_canvas {
            position: absolute;
            transform: scaleX(-1); /* é•œåƒç¿»è½¬ */
            object-fit: cover;
            width: 100%;
            height: 100%;
        }

        /* UI é¢æ¿æ ·å¼è°ƒæ•´ (Tweakpane) */
        .tp-dfwv {
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5), 0 4px 6px -2px rgba(0, 0, 0, 0.2);
            background-color: rgba(30, 41, 59, 0.9); /* åŠé€æ˜æ·±è“ */
            backdrop-filter: blur(8px);
            max-width: 320px;
        }

        /* é¡¶éƒ¨æ§åˆ¶æ  */
        #controls {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 100;
        }
        
        /* é’ˆå¯¹ç§»åŠ¨ç«¯ï¼Œå°†æ§åˆ¶é¢æ¿æ”¾åœ¨åº•éƒ¨å±…ä¸­ */
        @media (max-width: 640px) {
            #controls {
                top: auto;
                bottom: 10px;
                right: 0;
                left: 0;
                margin: 0 auto;
                max-width: 90%; 
            }
        }

        /* è­¦å‘Š/åŠ è½½ä¿¡æ¯ */
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 101;
            padding: 20px;
            text-align: center;
        }
    </style>
    <!-- å¼•å…¥ Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- å¼•å…¥ OrbitControls (é¼ æ ‡äº¤äº’) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- å¼•å…¥ MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <!-- å¼•å…¥ Tweakpane -->
    <script src="https://cdn.jsdelivr.net/npm/tweakpane@3.1.1/dist/tweakpane.min.js"></script>
</head>
<body>

    <!-- åŠ è½½å’Œæƒé™æç¤º -->
    <div id="loading-overlay" class="rounded-xl">
        <div class="text-3xl font-bold mb-4">ğŸ–ï¸ 3D ç²’å­ç³»ç»Ÿ - æ‰‹åŠ¿äº¤äº’</div>
        <p id="status-message" class="text-gray-400 mb-6 text-lg">æ­£åœ¨åŠ è½½æ¨¡å‹å’Œç­‰å¾…æ‘„åƒå¤´æƒé™...</p>
        <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-white"></div>
        <p class="mt-8 text-sm text-yellow-400">è¯·ç¡®ä¿è®¾å¤‡æœ‰è¶³å¤Ÿçš„å¤„ç†èƒ½åŠ›ï¼Œå¹¶æˆäºˆæ‘„åƒå¤´æƒé™ã€‚</p>
    </div>

    <!-- 3D æ¸²æŸ“å®¹å™¨ -->
    <div id="container"></div>
    
    <!-- æ‘„åƒå¤´å’Œç”»å¸ƒå®¹å™¨ (éšè—) -->
    <div id="video-container">
        <video id="webcam" autoplay playsinline></video>
        <canvas id="output_canvas"></canvas>
    </div>

    <!-- é¡¶éƒ¨æ§åˆ¶æŒ‰é’® -->
    <div id="controls" class="flex flex-col space-y-2">
        <button id="fullscreen-btn" 
                class="p-3 bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-full shadow-lg transition duration-150 ease-in-out"
                title="å…¨å±">
            <!-- Fullscreen Icon (lucide-react style) -->
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M8 3v3a2 2 0 0 1-2 2H3"/><path d="M21 8h-3a2 2 0 0 1-2-2V3"/><path d="M3 16h3a2 2 0 0 1 2 2v3"/><path d="M16 21v-3a2 2 0 0 1 2-2h3"/>
            </svg>
        </button>
    </div>

    <script>
        // --- å…¨å±€å˜é‡å’Œé…ç½® ---
        let camera, scene, renderer;
        let controls; 
        let particles, particleGeometry, particleMaterial;
        let hands, video; 
        let isCameraReady = false;
        let lastTimestamp = 0;
        const targetFPS = 30;
        const frameInterval = 1000 / targetFPS;

        // æ‰‹åŠ¿å¹³æ»‘å¤„ç†å†å²è®°å½•
        const spreadHistory = []; 
        const HISTORY_SIZE = 20; // å¹³æ»‘å¸§æ•°
        
        let captureIntervalId = null; 

        // UI çŠ¶æ€
        const PARAMS = {
            model: 'åœ£è¯æ ‘', 
            particleCount: 50000,
            particleSize: 0.1,
            color: '#FFFFFF',
            spreadFactor: 1.0,
            autoRotate: true,
            cameraZ: 10,
        };

        // é¢„å®šä¹‰çš„ç²’å­æ¨¡å‹ï¼ˆå‡ ä½•ä½“ç”Ÿæˆå‡½æ•°ï¼‰
        const MODELS = {
            'çˆ±å¿ƒ': generateHeart,
            'èŠ±æœµ': generateFlower,
            'å£«æ˜Ÿ': generateStar,
            'ä½›åƒ': generateSphere, 
            'çƒŸèŠ±': generateRandom,
            'åœ£è¯æ ‘': generateChristmasTree 
        };

        /**
         * @description å°†çƒåæ ‡è½¬æ¢ä¸ºç¬›å¡å°”åæ ‡ã€‚
         */
        function toVector(radius, phi, theta) {
            const x = radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.sin(phi) * Math.sin(theta);
            const z = radius * Math.cos(phi);
            return new THREE.Vector3(x, y, z);
        }

        /**
         * @description ç”Ÿæˆå¿ƒå½¢ç²’å­åˆ†å¸ƒã€‚
         */
        function generateHeart(count) {
            const positions = [];
            for (let i = 0; i < count; i++) {
                const t = Math.random() * (2 * Math.PI);
                const r = Math.random() * 0.5 + 1; 
                // 2D å¿ƒå½¢æ›²çº¿ (Cardioid)
                const x = r * 16 * Math.sin(t) ** 3;
                const y = r * (13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
                const z = (Math.random() - 0.5) * 40; // åœ¨ Z è½´ä¸Šæ·»åŠ æ·±åº¦
                
                positions.push(x * 0.1, y * 0.1, z * 0.1);
            }
            return { positions: new THREE.Float32BufferAttribute(positions, 3), colors: null };
        }

        /**
         * @description ç”ŸæˆèŠ±æœµå½¢çŠ¶çš„ç²’å­åˆ†å¸ƒã€‚
         */
        function generateFlower(count) {
            const positions = [];
            const R = 8;
            for (let i = 0; i < count; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI * 2;
                const r = R * Math.sqrt(Math.random()); 
                
                const x = r * Math.cos(theta) * (1 + Math.cos(phi) * 0.1);
                const y = r * Math.sin(theta) * (1 + Math.sin(phi) * 0.1);
                const z = r * Math.sin(r / R * Math.PI * 5) * 0.2; // æ³¢æµªå½¢çŠ¶
                
                positions.push(x * 0.5, y * 0.5, z * 0.5);
            }
            return { positions: new THREE.Float32BufferAttribute(positions, 3), colors: null };
        }

        /**
         * @description ç”Ÿæˆæ˜Ÿå½¢ç²’å­åˆ†å¸ƒã€‚
         */
        function generateStar(count) {
            const positions = [];
            const R = 10;
            for (let i = 0; i < count; i++) {
                const phi = Math.random() * Math.PI;
                const theta = Math.random() * Math.PI * 2;
                let radius = R * Math.cbrt(Math.random());

                // ç®€å•çš„æ˜Ÿå½¢æ‰°åŠ¨
                const factor = 1 + Math.sin(5 * theta) * 0.3 * Math.sin(phi) * 0.5; 
                radius *= factor;

                const pos = toVector(radius, phi, theta);
                positions.push(pos.x * 0.3, pos.y * 0.3, pos.z * 0.3);
            }
            return { positions: new THREE.Float32BufferAttribute(positions, 3), colors: null };
        }

        /**
         * @description ç”Ÿæˆçƒä½“å½¢çŠ¶çš„ç²’å­åˆ†å¸ƒã€‚
         */
        function generateSphere(count) {
            const positions = [];
            const R = 10;
            for (let i = 0; i < count; i++) {
                const phi = Math.random() * Math.PI;
                const theta = Math.random() * Math.PI * 2;
                const radius = R * Math.cbrt(Math.random());
                const pos = toVector(radius, phi, theta);
                positions.push(pos.x * 0.5, pos.y * 0.5, pos.z * 0.5);
            }
            return { positions: new THREE.Float32BufferAttribute(positions, 3), colors: null };
        }

        /**
         * @description ç”Ÿæˆéšæœºæ•£å°„çš„ç²’å­åˆ†å¸ƒ (çƒŸèŠ±æ•ˆæœ)ã€‚
         */
        function generateRandom(count) {
            const positions = [];
            for (let i = 0; i < count; i++) {
                const x = (Math.random() - 0.5) * 50;
                const y = (Math.random() - 0.5) * 50;
                const z = (Math.random() - 0.5) * 50;
                positions.push(x * 0.2, y * 0.2, z * 0.2);
            }
            return { positions: new THREE.Float32BufferAttribute(positions, 3), colors: null };
        }
        
        /**
         * @description ç”Ÿæˆå¸¦æœ‰é¢œè‰²å˜åŒ–çš„åœ£è¯æ ‘å½¢çŠ¶ç²’å­åˆ†å¸ƒã€‚
         */
        function generateChristmasTree(count) {
            const positions = [];
            const colors = [];
            
            // åœ£è¯å½©ç¯é¢œè‰²
            const colorPalette = [
                new THREE.Color(0xFF0000), new THREE.Color(0xFFFF00), 
                new THREE.Color(0x0000FF), new THREE.Color(0xFF8C00), 
                new THREE.Color(0xFFFFFF), 
            ];
            
            const treeHeight = 15;
            const baseRadius = 5;
            const ORNAMENT_COUNT = 50; 
            const ORNAMENT_DENSITY = 0.05; // 5% çš„ç²’å­ä½œä¸ºå½©ç¯

            const ornamentCenters = [];
            // éšæœºç”Ÿæˆå½©ç¯ä½ç½®
            for (let i = 0; i < ORNAMENT_COUNT; i++) {
                const h = Math.random() * treeHeight; 
                const radiusAtHeight = baseRadius * (1 - h / treeHeight);
                const radius = radiusAtHeight * (Math.random() * 0.8 + 0.1); 
                const theta = Math.random() * Math.PI * 2;
                
                const x = radius * Math.cos(theta);
                const y = h - treeHeight / 2; // Y è½´å±…ä¸­
                const z = radius * Math.sin(theta);

                ornamentCenters.push({
                    pos: new THREE.Vector3(x * 0.5, y * 0.5, z * 0.5), 
                    color: colorPalette[Math.floor(Math.random() * colorPalette.length)]
                });
            }

            // ç”Ÿæˆç²’å­
            for (let i = 0; i < count; i++) {
                let color;
                let finalX, finalY, finalZ;

                if (Math.random() > ORNAMENT_DENSITY) { 
                    // æ ‘å¶ (ç»¿è‰²)
                    const h = Math.random() * treeHeight; 
                    const radiusAtHeight = baseRadius * (1 - h / treeHeight);
                    const radius = radiusAtHeight * Math.random() * 0.9; 
                    const theta = Math.random() * Math.PI * 2;
                    
                    finalX = radius * Math.cos(theta);
                    finalY = h - treeHeight / 2;
                    finalZ = radius * Math.sin(theta);
                    
                    color = new THREE.Color(0x004d00); // æ·±ç»¿è‰²
                } else { 
                    // å½©ç¯ (å½©è‰²)
                    const centerIndex = Math.floor(Math.random() * ORNAMENT_COUNT);
                    const center = ornamentCenters[centerIndex];
                    
                    const spread = 0.2; 
                    finalX = center.pos.x + (Math.random() - 0.5) * spread;
                    finalY = center.pos.y + (Math.random() - 0.5) * spread;
                    finalZ = center.pos.z + (Math.random() - 0.5) * spread;
                    
                    color = center.color;
                }

                positions.push(finalX * 0.5, finalY * 0.5, finalZ * 0.5); // ç¼©æ”¾ä»¥é€‚åº”åœºæ™¯
                colors.push(color.r, color.g, color.b);
            }
            
            return { 
                positions: new THREE.Float32BufferAttribute(positions, 3), 
                colors: new THREE.Float32BufferAttribute(colors, 3) 
            };
        }

        // --- Three.js åˆå§‹åŒ– ---
        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = PARAMS.cameraZ;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);

            createParticles();

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; 
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 5; 
            controls.maxDistance = 100; 

            window.addEventListener('resize', onWindowResize);
            document.getElementById('fullscreen-btn').addEventListener('click', toggleFullscreen);

            initTweakpane();
        }

        /**
         * @description æ ¹æ®å½“å‰æ¨¡å‹å‚æ•°åˆ›å»ºæˆ–é‡ç½®ç²’å­ç³»ç»Ÿã€‚
         */
        function createParticles() {
            if (particles) {
                scene.remove(particles);
                particleGeometry.dispose();
            }

            const generator = MODELS[PARAMS.model];
            const data = generator(PARAMS.particleCount); 

            particleGeometry = new THREE.BufferGeometry();
            particleGeometry.setAttribute('position', data.positions);

            const useVertexColors = !!data.colors;

            if (useVertexColors) {
                particleGeometry.setAttribute('color', data.colors);
            }

            // åˆ›å»º PointsMaterial
            particleMaterial = new THREE.PointsMaterial({
                size: PARAMS.particleSize,
                color: useVertexColors ? 0xffffff : new THREE.Color(PARAMS.color), 
                vertexColors: useVertexColors, 
                sizeAttenuation: true, // ç²’å­å¤§å°éšè·ç¦»å˜åŒ–
                transparent: true,
                opacity: 0.8,
                depthWrite: false, // ç¦ç”¨æ·±åº¦å†™å…¥ä»¥é¿å…æ¸²æŸ“ä¼ªå½±
                blending: THREE.AdditiveBlending, // å åŠ æ··åˆï¼Œè¥é€ å‘å…‰æ•ˆæœ
            });

            particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
        }

        /**
         * @description ä¸»æ¸²æŸ“å¾ªç¯ã€‚
         */
        function animate(timestamp) {
            requestAnimationFrame(animate);

            const elapsed = timestamp - lastTimestamp;
            if (elapsed > frameInterval) {
                lastTimestamp = timestamp - (elapsed % frameInterval);

                if (controls) {
                    controls.update();
                }

                if (particles && PARAMS.autoRotate) {
                    particles.rotation.x += 0.001;
                    particles.rotation.y += 0.002;
                    particles.rotation.z += 0.003;
                }

                renderer.render(scene, camera);
            }
        }

        /**
         * @description çª—å£å¤§å°æ”¹å˜æ—¶è°ƒæ•´æ¸²æŸ“å™¨å’Œæ‘„åƒæœºã€‚
         */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Tweakpane UI åˆå§‹åŒ– ---
        function initTweakpane() {
            const pane = new Tweakpane.Pane({
                title: 'ç²’å­æ§åˆ¶é¢æ¿',
                expanded: true,
                container: document.getElementById('controls')
            });

            const modelFolder = pane.addFolder({ title: 'æ¨¡å‹å’Œé¢œè‰²' });
            modelFolder.addInput(PARAMS, 'model', {
                options: {
                    'åœ£è¯æ ‘': 'åœ£è¯æ ‘', 
                    'çˆ±å¿ƒ': 'çˆ±å¿ƒ',
                    'èŠ±æœµ': 'èŠ±æœµ',
                    'å£«æ˜Ÿ': 'å£«æ˜Ÿ',
                    'ä½›åƒ (çƒä½“)': 'ä½›åƒ',
                    'çƒŸèŠ± (éšæœº)': 'çƒŸèŠ±',
                }
            }).on('change', () => { createParticles(); });

            modelFolder.addInput(PARAMS, 'color', {
                label: 'ç²’å­é¢œè‰²',
                view: 'color',
                color: { type: 'string' }
            }).on('change', (ev) => {
                // ä»…åœ¨é vertexColor æ¨¡å‹ä¸‹æ”¹å˜é¢œè‰²
                if (particleMaterial && PARAMS.model !== 'åœ£è¯æ ‘') {
                    particleMaterial.color.set(ev.value);
                }
            });

            const visualFolder = pane.addFolder({ title: 'è§†è§‰å‚æ•°' });
            
            visualFolder.addInput(PARAMS, 'particleSize', {
                label: 'ç²’å­å¤§å°',
                min: 0.01,
                max: 1.0,
                step: 0.01
            }).on('change', (ev) => {
                if (particleMaterial) { particleMaterial.size = ev.value; }
            });

            visualFolder.addInput(PARAMS, 'particleCount', {
                label: 'ç²’å­æ•°é‡',
                min: 1000,
                max: 100000,
                step: 1000
            }).on('change', () => { createParticles(); });

            visualFolder.addInput(PARAMS, 'autoRotate', { label: 'è‡ªåŠ¨æ—‹è½¬' });
            
            visualFolder.addInput(PARAMS, 'spreadFactor', {
                label: 'æ‰‹åŠ¿æ‰©æ•£ (Read-only, 20å¸§å¹³å‡)',
                min: 0.1,
                max: 2.0,
                step: 0.01,
                readonly: true,
            });
        }

        // --- MediaPipe Hand Tracking é€»è¾‘ ---

        /**
         * @description è®¡ç®—ä¸¤ç‚¹é—´çš„æ¬§å‡ é‡Œå¾—è·ç¦»ã€‚
         */
        function distance(p1, p2) {
            const dx = p1.x - p2.x;
            const dy = p1.y - p2.y;
            const dz = p2.z - p1.z; 
            return Math.sqrt(dx * dx + dy * dy + dz * dz);
        }

        /**
         * @description å¤„ç† MediaPipe çš„æ‰‹åŠ¿ç»“æœã€‚
         */
        function onResults(results) {
            if (!particles) return;

            const handsData = results.multiHandLandmarks;

            if (handsData && handsData.length > 0) {
                const hand = handsData[0]; 
                
                // å…³é”®ç‚¹ï¼šæ‹‡æŒ‡å°– (4) å’Œé£ŸæŒ‡å°– (8)
                const p1 = hand[4];
                const p2 = hand[8];
                const d = distance(p1, p2);
                    
                // å°†è·ç¦» d æ˜ å°„åˆ°ä¸€ä¸ªåæ¯”çš„ç¼©æ”¾å› å­ maxDist (æåˆ -> æ”¾å¤§)
                let maxDist = 1 - d * 3; 
                maxDist = Math.max(0.1, Math.min(1.0, maxDist));

                // ç¬æ—¶æ‰©æ•£å› å­ (ç”¨äºå¹³æ»‘)
                let instantaneousSpread = 0.5 + maxDist * 1.5; 
                
                // æ·»åŠ åˆ°å†å²è®°å½•å¹¶è®¡ç®—å¹³å‡å€¼è¿›è¡Œå¹³æ»‘
                spreadHistory.push(instantaneousSpread);
                if (spreadHistory.length > HISTORY_SIZE) {
                    spreadHistory.shift();
                }

                const avgSpread = spreadHistory.reduce((a, b) => a + b, 0) / spreadHistory.length;
                
                const scale = avgSpread * 10;
                particles.scale.set(scale, scale, scale);

                // æ›´æ–° UI
                PARAMS.spreadFactor = parseFloat(avgSpread.toFixed(2));

            } else {
                // æœªæ£€æµ‹åˆ°æ‰‹æ—¶æ¢å¤é»˜è®¤ç¼©æ”¾
                if (particles) {
                    particles.scale.set(10, 10, 10);
                }
                spreadHistory.length = 0; 
            }
        }

        // --- æ‘„åƒå¤´å’Œ MediaPipe å¯åŠ¨ ---
        /**
         * @description è®¾ç½®æ‘„åƒå¤´å’Œ MediaPipe æ¨¡å‹ã€‚
         */
        async function setupCameraAndHands() {
            video = document.getElementById('webcam');
            const statusElement = document.getElementById('status-message');

            try {
                statusElement.innerText = 'æ­£åœ¨è¯·æ±‚æ‘„åƒå¤´æƒé™...';
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'user' } 
                });
                video.srcObject = stream;

                await new Promise((resolve) => {
                    video.onloadedmetadata = () => { resolve(video); };
                });

                statusElement.innerText = 'æ­£åœ¨åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«æ¨¡å‹...';
                hands = new Hands({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                    }
                });

                hands.setOptions({
                    maxNumHands: 2,
                    modelComplexity: 1, 
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                hands.onResults(onResults);

                isCameraReady = true;
                statusElement.innerHTML = 'âœ… æ‘„åƒå¤´å’Œæ¨¡å‹å·²å°±ç»ªã€‚<br>è‡ªåŠ¨æ•æ‰å·²å¯åŠ¨ã€‚';
                document.getElementById('loading-overlay').style.display = 'none'; 

                startAutoCapture(); 

                video.play();
                sendToMediaPipe();

            } catch (error) {
                console.error('Error accessing camera or initializing MediaPipe:', error);
                statusElement.innerHTML = `âš ï¸ é”™è¯¯: æ— æ³•å¯åŠ¨æ‘„åƒå¤´æˆ–åŠ è½½æ¨¡å‹ã€‚<br>è¯·æ£€æŸ¥æƒé™æˆ–å°è¯•åˆ·æ–°ã€‚é”™è¯¯ä¿¡æ¯: ${error.message}`;
                document.getElementById('loading-overlay').classList.add('bg-red-800');
            }
        }

        /**
         * @description å¾ªç¯å‘é€è§†é¢‘å¸§åˆ° MediaPipe è¿›è¡Œå¤„ç†ã€‚
         */
        async function sendToMediaPipe() {
            if (!isCameraReady) return;
            
            await hands.send({ image: video });

            requestAnimationFrame(sendToMediaPipe);
        }

        /**
         * @description åˆ‡æ¢å…¨å±æ¨¡å¼ã€‚
         */
        function toggleFullscreen() {
            const elem = document.documentElement;
            if (document.fullscreenElement) {
                document.exitFullscreen().catch(err => {
                    console.warn('é€€å‡ºå…¨å±å¤±è´¥:', err.name, err.message);
                });
            } else if (elem.requestFullscreen) {
                elem.requestFullscreen().catch(err => {
                    console.warn('è¯·æ±‚å…¨å±å¤±è´¥:', err.name, err.message);
                });
            }
        }

        // --- ä¸»ç¨‹åºå…¥å£ ---
        window.onload = () => {
            initThree();
            animate(0); 
            setupCameraAndHands(); 
        };

    </script>
</body>
</html>